// Generated by ToffeeScript 1.6.3-4
(function() {
  var ModuleComplete, NameModuleBase, assert, async, exec, fs, ok, path, util, utils, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  NameModuleBase = require('./ModuleBase').NameModuleBase;

  util = require('util');

  fs = require('fs');

  exec = require('child_process').exec;

  path = require('path');

  _ = require('underscore');

  async = require('async');

  ok = require('okay');

  assert = require('assert-plus');

  utils = require('../utils');

  ModuleComplete = (function(_super) {
    __extends(ModuleComplete, _super);

    function ModuleComplete(module, cmd, next) {
      ModuleComplete.__super__.constructor.call(this, module, cmd, next);
    }

    ModuleComplete.prototype.onDirExists_ = function() {
      var _this = this;
      return async.waterfall([this.getFolders_.bind(this), this.getReposStatus_.bind(this), this.conditionalCommit_.bind(this)], function(err) {
        return _this.next(err);
      });
    };

    ModuleComplete.prototype.getFolders_ = function(cb) {
      var configCnt, file, folders, has_dot_git, list, name, pending, stat, _i, _len;
      assert.func(cb);
      folders = [];
      list = fs.readdirSync(mfe.path.work_dir);
      pending = list.length;
      if (!pending) {
        return [];
      }
      for (_i = 0, _len = list.length; _i < _len; _i++) {
        name = list[_i];
        file = path.join(mfe.path.work_dir, name);
        stat = fs.statSync(file);
        if (stat.isDirectory()) {
          if (!/^\./i.test(name)) {
            has_dot_git = fs.existsSync("" + file + "/.git");
            if (has_dot_git) {
              configCnt = fs.readFileSync("" + file + "/.git/config", "utf8");
              if (/url\s*=\s*git@git\.mofang\.com\:mfe\/.+\.git/im.test(configCnt)) {
                folders.push(name);
              }
            }
          }
        }
      }
      this.folders = folders;
      return cb();
    };

    ModuleComplete.prototype.conditionalCommit_ = function(cb) {
      var foldersStatus, module_need_commit, no_commit, others_need_commit,
        _this = this;
      assert.func(cb);
      others_need_commit = false;
      no_commit = true;
      module_need_commit = true;
      _.forEach(this.status, function(stat) {
        if (stat.module !== module && !stat.no_modify) {
          others_need_commit = true;
        }
        if (!stat.no_modify) {
          no_commit = false;
        }
        if (stat.module === module && !stat.no_modify) {
          return module_need_commit = true;
        }
      });
      if (no_commit) {
        console.log("没有模块需要提交");
        cb(null);
        return false;
      }
      foldersStatus = [];
      if (others_need_commit) {
        if (module_need_commit) {
          return utils.ask_if("检查到其他模块有修改，是否一起提交", function(err, answer) {
            if (answer) {
              _.forEach(_this.status, function(stat) {
                if (!stat.no_modify) {
                  return foldersStatus.push(stat);
                }
              });
              return _this.commitFolders_(foldersStatus, cb);
            } else {
              _.forEach(_this.status, function(stat) {
                if (stat.module === module) {
                  return foldersStatus.push(stat);
                }
              });
              return _this.commitFolders_([module], cb);
            }
          });
        } else {
          return utils.ask_if("[" + module + "]模块没有修改,但其他模块有修改，是否提交", function(err, answer) {
            if (answer) {
              _.forEach(_this.status, function(stat) {
                if (!stat.no_modify) {
                  return foldersStatus.push(stat);
                }
              });
              return _this.commitFolders_(_this.folders, cb);
            } else {
              return cb(null);
            }
          });
        }
      } else {
        _.forEach(this.status, function(stat) {
          if (!stat.no_modify) {
            return foldersStatus.push(stat);
          }
        });
        return this.commitFolders_(foldersStatus, cb);
      }
    };

    ModuleComplete.prototype.getReposStatus_ = function(cb) {
      var status,
        _this = this;
      assert.func(cb);
      status = [];
      return async.each(this.folders, function(module, cb) {
        var child, cmd_init_git;
        assert.func(cb);
        cmd_init_git = "cd " + mfe.path.work_dir + "                && cd " + module + "                && git status                ";
        return child = exec(cmd_init_git, function(err, stdout, stderr) {
          var stat, status_has_push, status_has_uncommit, status_no_modify, status_not_staged, status_untracked_files;
          stat = {
            module: module
          };
          if (err) {
            console.log('exec error: ' + err);
            return cb("查询状态失败!");
          } else {
            status_no_modify = /nothing\s+to\s+commit/ig.test(stdout) && !/by\s+\d+\s+commit/ig.test(stdout);
            status_untracked_files = /untracked\s+files/ig.test(stdout);
            status_has_uncommit = /changes\s+to\s+be\s*committed/ig.test(stdout);
            status_has_push = /by\s+\d+\s+commit/ig.test(stdout) && /use\s+\"git\s+push\"/ig.test(stdout);
            status_not_staged = /changes\s+not\s+staged/ig.test(stdout) && /use\s+\"git\s+add\"/ig.test(stdout);
            stat.no_modify = status_no_modify;
            stat.untracked_files = status_untracked_files;
            stat.has_uncommit = status_has_uncommit;
            stat.has_push = status_has_push;
            stat.not_staged = status_not_staged;
            status.push(stat);
            return cb(null);
          }
        });
      }, function(err) {
        _this.status = status;
        return cb(err);
      });
    };

    ModuleComplete.prototype.commitFolders_ = function(status, next) {
      function line() {};
      return async.eachSeries(status, function(stat, next) {
        var cmd_commit;
        function after_commit(next) {
          var child;
          cmd_commit += " && git pull";
          cmd_commit += " && git push";
          cmd_commit += "";
          line();
          return child = exec(cmd_commit, function(err, stdout, stderr) {
            console.log(stdout);
            line();
            if (err) {
              return next("shell命令失败!");
            } else {
              return next(null);
            }
          });
        };
        cmd_commit = "cd " + mfe.path.work_dir + " && cd " + stat.module;
        if (stat.untracked_files || stat.not_staged) {
          cmd_commit += "&& git add -A";
        }
        if (stat.has_uncommit || stat.untracked_files || stat.not_staged) {
          return utils.ask_for_input("请输入提交注释:(默认:模块[" + stat.module + "]内容修改)", null, function(err, answer) {
            var commit_msg;
            if (err) {
              next(err);
              return;
            }
            commit_msg = "模块[" + stat.module + "]内容修改";
            if (answer.length) {
              commit_msg = answer;
            }
            cmd_commit += " && git commit -m \"" + commit_msg + "\"";
            return after_commit(next);
          });
        } else {
          return after_commit(next);
        }
      }, next);
    };

    return ModuleComplete;

  })(NameModuleBase);

  module.exports = {};

  module.exports.ModuleComplete = ModuleComplete;

}).call(this);
